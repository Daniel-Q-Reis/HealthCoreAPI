"""
gRPC Client for Audit Microservice

This module provides a Python client to communicate with the Go-based
Audit Log Microservice via gRPC.
"""

import logging
from datetime import datetime
from typing import Any, Optional

import grpc

# These imports will be auto-generated by protoc
# For now, we'll document the expected interface
# TODO: Run protoc to generate Python stubs from audit.proto

logger = logging.getLogger(__name__)


class AuditGRPCClient:
    """
    gRPC client for the Audit Microservice.

    Usage:
        client = AuditGRPCClient(host='audit-service', port=50051)
        client.log_event(
            actor_id='USER-123',
            action='PATIENT_VIEW',
            target_id='PAT-456',
            resource_type='PATIENT',
            ip_address='192.168.1.1',
            details={'reason': 'Treatment review'}
        )
    """

    def __init__(
        self, host: str = "audit-service", port: int = 50051, timeout: int = 5
    ):
        """
        Initialize the gRPC client.

        Args:
            host: Audit service hostname (default: 'audit-service' for Docker)
            port: gRPC port (default: 50051)
            timeout: Request timeout in seconds
        """
        self.host = host
        self.port = port
        self.timeout = timeout
        self.channel: Optional[grpc.Channel] = None
        self.stub = None

    def connect(self):
        """Establish connection to the Audit gRPC service."""
        try:
            target = f"{self.host}:{self.port}"
            self.channel = grpc.insecure_channel(target)
            # TODO: Import generated stub
            # from src.apps.core.proto import audit_pb2_grpc
            # self.stub = audit_pb2_grpc.AuditServiceStub(self.channel)
            logger.info(f"✅ Connected to Audit Service at {target}")
        except Exception as e:
            logger.error(f"❌ Failed to connect to Audit Service: {e}")
            raise

    def close(self):
        """Close the gRPC channel."""
        if self.channel:
            self.channel.close()
            logger.info("gRPC channel closed")

    def log_event(
        self,
        actor_id: str,
        action: str,
        target_id: Optional[str] = None,
        resource_type: str = "",
        ip_address: str = "",
        user_agent: str = "",
        details: Optional[dict[str, Any]] = None,
        timestamp: Optional[datetime] = None,
    ) -> str:
        """
        Log an audit event via gRPC.

        Args:
            actor_id: ID of the user performing the action
            action: Action performed (e.g., 'PATIENT_VIEW', 'LOGIN')
            target_id: ID of the target resource (defaults to actor_id)
            resource_type: Type of resource (e.g., 'PATIENT', 'USER')
            ip_address: Source IP address
            user_agent: Client user agent
            details: Additional context as a dictionary
            timestamp: Event timestamp (defaults to now)

        Returns:
            event_id: Unique identifier for the logged event
        """
        if not self.stub:
            self.connect()

        try:
            # TODO: Use generated protobuf classes
            # from src.apps.core.proto import audit_pb2
            #
            # request = audit_pb2.LogEventRequest(
            #     actor_id=actor_id,
            #     action=action,
            #     target_id=target_id or actor_id,
            #     resource_type=resource_type,
            #     ip_address=ip_address,
            #     user_agent=user_agent,
            #     details=json.dumps(details or {}),
            #     timestamp=int(timestamp.timestamp()) if timestamp else 0
            # )
            #
            # response = self.stub.LogEvent(request, timeout=self.timeout)
            # logger.info(f"✅ Audit event logged: {response.event_id}")
            # return response.event_id

            # Placeholder until protoc is run
            logger.warning("⚠️ gRPC client not yet implemented - please run protoc")
            return "placeholder-event-id"

        except grpc.RpcError as e:
            logger.error(f"❌ gRPC error logging event: {e.code()} - {e.details()}")
            raise
        except Exception as e:
            logger.error(f"❌ Error logging audit event: {e}")
            raise

    def get_audit_logs(
        self, target_id: str, limit: int = 50, next_token: Optional[str] = None
    ) -> list[dict[str, Any]]:
        """
        Retrieve audit logs for a specific entity.

        Args:
            target_id: Entity ID to filter by
            limit: Maximum number of records to return
            next_token: Pagination token

        Returns:
            List of audit log entries as dictionaries
        """
        if not self.stub:
            self.connect()

        try:
            # TODO: Use generated protobuf classes
            # from src.apps.core.proto import audit_pb2
            #
            # request = audit_pb2.GetAuditLogsRequest(
            #     target_id=target_id,
            #     limit=limit,
            #     next_token=next_token or ''
            # )
            #
            # response = self.stub.GetAuditLogs(request, timeout=self.timeout)
            #
            # logs = []
            # for entry in response.logs:
            #     logs.append(json_format.MessageToDict(entry))
            #
            # logger.info(f"✅ Retrieved {len(logs)} audit logs for {target_id}")
            # return logs

            # Placeholder until protoc is run
            logger.warning("⚠️ gRPC client not yet implemented - please run protoc")
            return []

        except grpc.RpcError as e:
            logger.error(f"❌ gRPC error retrieving logs: {e.code()} - {e.details()}")
            raise
        except Exception as e:
            logger.error(f"❌ Error retrieving audit logs: {e}")
            raise

    def __enter__(self):
        """Context manager entry."""
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.close()


# Singleton instance for global access
_audit_client: Optional[AuditGRPCClient] = None


def get_audit_client() -> AuditGRPCClient:
    """Get or create the global Audit gRPC client instance."""
    global _audit_client
    if _audit_client is None:
        _audit_client = AuditGRPCClient()
    return _audit_client
